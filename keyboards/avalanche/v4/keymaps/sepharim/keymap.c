#include QMK_KEYBOARD_H

#include "my_keymap.h"

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

enum layer {
    _BASE,
    _NAV,
    _FN,
    _SGN,
};




const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = MY_LAYOUT6(
              xxxxxxx , KC_X    , KC_V    , KC_L    , KC_C    , KC_W    ,           KC_K    , KC_H    , KC_G    , KC_F    , KC_Q    , DE_SS   ,
              xxxxxxx , MY_U    , MY_I    , MY_A    , MY_E    , KC_O    ,           KC_S    , MY_N    , MY_R    , MY_T    , MY_D    , DE_Y    ,
              xxxxxxx , DE_UDIA , DE_ODIA , DE_ADIA , KC_P    , DE_Z    ,           KC_B    , KC_M    , KC_COMM , KC_DOT  , KC_J    , xxxxxxx , 
                                                      SGN_SPC , FN      ,           CAPSWRD , NAV_ENT),
    [_NAV]  = MY_LAYOUT(
                        KC_PGUP , KC_BSPC , KC_UP   , KC_DEL  , KC_PGDN ,           xxxxxxx , KC_7    , KC_8    , KC_9    , xxxxxxx ,
                        KC_HOME , KC_LEFT , KC_DOWN , KC_RGHT , KC_END  ,           xxxxxxx , MY_4    , MY_5    , MY_6    , MY_Nxxx ,
                        KC_ESC  , KC_TAB  , KC_INS  , KC_ENT  , xxxxxxx ,           KC_0    , KC_1    , KC_2    , KC_3    , xxxxxxx ,
                                                      _______ , _______ ,           KC_LSFT , _______),
    [_FN]   = MY_LAYOUT(
                        _______ , _______ , _______ , _______ , _______ ,           xxxxxxx , KC_F7   , KC_F8   , KC_F9   , KC_F10  ,
                        _______ , _______ , _______ , _______ , _______ ,           xxxxxxx , KC_F4   , KC_F5   , KC_F6   , KC_F11  ,
                        _______ , _______ , _______ , _______ , _______ ,           xxxxxxx , KC_F1   , KC_F2   , KC_F3   , KC_F12  ,
                                                      _______ , _______ ,           _______ , _______),
    [_SGN]  = MY_LAYOUT6(
              xxxxxxx , DE_AT   , DE_UNDS , DE_LBRC , DE_RBRC , DE_CIRC ,           DE_EXLM , DE_LABK , DE_RABK , DE_EQL  , DE_AMPR , xxxxxxx ,
              xxxxxxx , DE_BSLS , DE_SLSH , DE_LCBR , DE_RCBR , DE_ASTR ,           DE_QUES , DE_LPRN , DE_RPRN , DE_MINS , DE_COLN , DE_AT   ,
              xxxxxxx , DE_HASH , DE_DLR  , DE_PIPE , DE_TILD , DE_GRV  ,           DE_PLUS , DE_PERC , DE_DQUO , DE_QUOT , DE_SCLN , xxxxxxx ,
                                                      _______ , _______ ,           _______ , _______)
};

bool should_process_keypress(void) { return true; }
bool get_custom_auto_shifted_key(uint16_t keycode, keyrecord_t *record) {
    switch(keycode) {
        case KC_A ... KC_Z:
        //German Umlauts
        case DE_UDIA:
        case DE_ODIA:
        case DE_ADIA:
        //ModTap Keys
        case MY_E:
        case MY_A:
        case MY_I:
        case MY_U:
        case MY_N:
        case MY_R:
        case MY_T:
        case MY_D:
            return true;
        //MouseKeys on Numpad
    }
    return false;
}
layer_state_t layer_state_set_user(layer_state_t state) {
#ifdef AUTO_SHIFT_ENABLE
    if (get_autoshift_state() && (state & (1<<_FN) || state & (1<<_SGN) || state & (1<<_NAV))) {
        autoshift_disable();
    } else {
        autoshift_enable();
    }
#endif

#ifdef RGB_MATRIX_ENABLE
    switch (get_highest_layer(state)) {
    case _NAV:
        rgb_matrix_sethsv_noeeprom (0xFF,  0xFF, 0x77);
        break;
    case _FN:
        rgb_matrix_sethsv_noeeprom (0xA0,  0xFF, 0x77);
        break;
    case _SGN:
        rgb_matrix_sethsv_noeeprom (0x7A,  0xFF, 0x77);
        break;
    default: //  for any other layers, or the default layer
        rgb_matrix_sethsv_noeeprom (0x50,  0xFF, 0xFF);
        break;
    }
#endif
#ifdef RGBLIGHT_ENABLE
    switch (get_highest_layer(state)) {
    case _NAV:
        rgblight_sethsv_noeeprom (0xFF,  0xFF, 0x77);
        break;
    case _FN:
        rgblight_sethsv_noeeprom (0xA0,  0xFF, 0x77);
        break;
    case _SGN:
        rgblight_sethsv_noeeprom (0x7A,  0xFF, 0x77);
        break;
    default: //  for any other layers, or the default layer
        rgblight_sethsv_noeeprom (0x50,  0xFF, 0xFF);
        break;
    }
#endif
  
#ifdef OLED_ENABLE
oled_write_P(PSTR("\n"), false); 
if (is_keyboard_master()) {
  switch (get_highest_layer(state)) {
    case _NAV:
      //                 123456789012345678901
      oled_write_P(PSTR("      Num & Nav      "), false);
      oled_write_P(PSTR("  _   _  _  _  _  _  "), false);
      oled_write_P(PSTR("  _   PU BS NU DE PD "), false);
      oled_write_P(PSTR("  _   HO NL ND NR EN "), false);
      oled_write_P(PSTR("  _   _  _  _  _  _  "), false);
      break;
    case _SGN:
            //                 123456789012345678901
      oled_write_P(PSTR("         SGN         "), false);
      oled_write_P(PSTR("  _   _  _  _  _  _  "), false);
      oled_write_P(PSTR("  _   @  _  [  ]  ^  "), false);
      oled_write_P(PSTR("  _   \\  /  {  }  *  "), false);
      oled_write_P(PSTR("  _   #  $  |  ~  `  "), false);
      break;
    default:
      //                 123456789012345678901
      oled_write_P(PSTR("        BASE         "), false);
      oled_write_P(PSTR(" ESC  1  2  3  4  5  "), false);
      oled_write_P(PSTR(" TAB  x  v  l  c  w  "), false);
      oled_write_P(PSTR(" ???  u  i  a  e  o  "), false);
      oled_write_P(PSTR(" SHI  ue oe ae p  z  "), false);
      break;
  }
} else {
    switch (get_highest_layer(state)) {
    case _NAV:
      //                 123456789012345678901
      oled_write_P(PSTR("      Num & Nav      "), false);
      oled_write_P(PSTR(" _  _  _  _  _   _   "), false);
      oled_write_P(PSTR(" _  7  8  9  _   _   "), false);
      oled_write_P(PSTR(" _  4  5  6  _   _   "), false);
      oled_write_P(PSTR(" 0  1  2  3  _   _   "), false);
      break;
    case _SGN:
      //                 123456789012345678901
      oled_write_P(PSTR("         SGN         "), false);
      oled_write_P(PSTR(" _  _  _  _  _   _   "), false);
      oled_write_P(PSTR(" !  ^  Â°  =  &   _   "), false);
      oled_write_P(PSTR(" ?  (  )  -  :   @   "), false);
      oled_write_P(PSTR(" +  \%  \"  '  ;   _   "), false);
      break;
    default:
      //                 123456789012345678901
      oled_write_P(PSTR("        BASE         "), false);
      oled_write_P(PSTR(" 6  7  8  9  0  EUR  "), false);
      oled_write_P(PSTR(" k  h  g  f  q   ss  "), false);
      oled_write_P(PSTR(" s  n  r  t  d   y   "), false);
      oled_write_P(PSTR(" b  m  ,  .  j  SHI  "), false);
      break;
  }
}
#endif
  return state;
};

bool oled_task_user(void) {
    //oled_write_P(PSTR("Avalanche - sepharim\n"), false);
    return true;
}
bool caps_word_press_user(uint16_t keycode) {
    switch (keycode) {
        // Keycodes that continue Caps Word, with shift applied.
        case KC_A ... KC_Z:
        case KC_MINS:
            add_weak_mods(MOD_BIT(KC_LSFT));  // Apply shift to next key.
            return true;

        // Keycodes that continue Caps Word, without shifting.
        case KC_1 ... KC_0:
        case KC_BSPC:
        case KC_DEL:
        case KC_UNDS:
        case DE_UNDS:
        case DE_LPRN:
        case DE_RPRN:
            return true;

        default:
            return false;  // Deactivate Caps Word.
    }
}
#ifdef ENCODER_ENABLE
bool encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 1) { /* Second encoder */
        if (clockwise) {
            tap_code(KC_WH_U);
        } else {
            tap_code(KC_WH_D);
        }
        return false;
    }
    return true;
}
#endif